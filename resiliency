Resiliency in microservices refers to the ability of the application to overcome failures, stay available, and deliver consistent performance in
distributed environments.
Implementing resiliency patterns in microservices offers several benefits :

- minimized service downtime    : the applications recover quickly from failures, which minimize disruptions and ensuring high availability for users.
- fault isolation               : because the developers can isolate failures, preventing them from spreading.
- consistent system performance : a resilient microservices application can maintain consistent performance, even under high load or network issues.






To implement resiliency in the Java ecosystem, it exist various pattern such as Resilience4J and Hystrix (maintenance mode)

Resilience4J is a fault tolerance library, that offers many pattern to increase fault tolerance :

- Circuit Breaker : It monitor the requests, if the request take a lot of time than expected, it will intercede and stop the request, and also
                    if a enough number of requests gets failed, it will fails them fast and prevents future requests to the remote failing
                    resource until it is fixed.
                    It has 2 status, initially it is CLOSED accepts client requests, and once the failure rate has been reached, it becomes OPEN,
                    but it will be periodically HALF_OPEN to checks if the issue has been fixed by allowing some few requests, and based on the results
                    it will go either OPEN or CLOSED.

- Fallback        : It is used to implement alternative paths or implementation (in case of feign clients) for failing requests.

- Retry           : It is used to implement multiple retry attempts when a service is temporarily failed (either with retry annotation or using gateway routes).

- Rate limit      : It is used to limits the number of calls that a service receives in a time.
                    The Redis implementation is based on work done at Stripe. It requires the use of the spring-boot-starter-data-redis-reactive
                    spring Boot starter, the algorithm used is the Token Bucket Algorithm which 3 properties should be set :
                          - redis-rate-limiter.replenishRate: defines how many requests per second to allow (without any dropped requests),
                                                              this is the rate at which the token bucket is filled.
                          - redis-rate-limiter.burstCapacity: is the maximum number of requests a user is allowed in a single second (without any
                                                              dropped requests). This is the number of tokens the token bucket can hold. Setting this
                                                              value to zero blocks all requests.
                          - redis-rate-limiter.requestedTokens: is how many tokens a request costs. This is the number of tokens taken from the bucket
                                                                for each request and defaults to 1.


- Bulkhead        : It is a pattern used to limits the number of outgoing concurrent requests to a service to avoid overloading. it is used to define
                    the boundaries for an api inside a microservice, for instance, if you have 2 apis A and B, and A is more consuming as it has more
                    business logic, without bulkhead it will consume all the threads and all the resources available inside the docker container,
                    so at some point of time, the api B is not going to get enough threads and resources, but with the help of bulkhead, we can define
                    boundaries like thread pool size, to define how many thread and resources is allowed for the api A to not overload it.



